Day 1：项目骨架 + 环境一键启动

目标

把项目跑起来，形成工程骨架和基础开发体验。

任务
	•	建 repo 结构（建议如下）
	•	Docker Compose：api / mysql / redis
	•	基础配置：.env、settings（pydantic-settings）
	•	健康检查：GET /health

建议目录结构
	•	app/
	•	main.py
	•	core/（settings、security、logging）
	•	db/（engine、session、base）
	•	models/
	•	schemas/
	•	api/（routers）
	•	services/
	•	workers/（异步任务）
	•	tests/
	•	alembic/
	•	docker-compose.yml

Done 标准
	•	docker compose up 后：
	•	MySQL 可连
	•	Redis 可 ping
	•	/health 返回 ok
	•	/docs 可打开

⸻

Day 2：账户系统（注册/登录/刷新令牌）+ Redis Token 黑名单

目标

有完整的登录体系，并且 Redis 真正参与“安全控制”。

任务
	•	用户表 + 密码 hash（bcrypt/argon2）
	•	注册、登录（JWT access + refresh）
	•	refresh rotation：刷新时旧 refresh token 作废（更像真实生产）
	•	Redis 存 refresh token 状态 / 黑名单

Redis Key 设计（示例）
	•	auth:refresh:{jti} → user_id，TTL=refresh_exp
	•	auth:blacklist:{jti} → 1，TTL=access_exp（可选）

你也可以只做 refresh 的 allowlist（更干净）。

Done 标准
	•	能注册、登录、刷新
	•	refresh token 被重复使用会失败（rotation 生效）
	•	pytest 覆盖 6-8 个用例（成功/失败/重复刷新）

⸻

Day 3：多租户 Workspace + 成员邀请（异步邮件/通知）+ RBAC 雏形

目标

引入 Workspace 概念，实现“数据隔离”和“成员/角色”。

数据模型（核心）
	•	users
	•	workspaces
	•	workspace_members（user_id, workspace_id, role）
	•	invites（workspace_id, email, token, expires_at, status）

角色建议（够用且经典）
	•	OWNER / ADMIN / MEMBER / GUEST

任务
	•	创建 workspace
	•	邀请成员（生成 invite token）
	•	接受邀请加入 workspace
	•	异步任务：邀请通知（先用 queue 写到日志/模拟发邮件）
	•	RQ：enqueue(send_invite, ...)

Redis Key（邀请 token 可放 DB 或 Redis）
	•	简化：invite token 存 DB（更可追踪）
	•	加分：Redis 作为 invite token 的快速校验缓存：
	•	invite:{token} → invite_id TTL=expires

Done 标准
	•	workspace 创建、邀请、接受邀请完整闭环
	•	成员角色写入 workspace_members
	•	至少 1 个 worker 能跑起来（RQ worker 或 Arq）

⸻

Day 4：项目 Project + 任务 Task（CRUD）+ Workspace 数据隔离（强制）

目标

真正的业务实体上线，并且所有查询都强制走 workspace 边界。

数据模型（补充）
	•	projects（workspace_id, name, description）
	•	tasks（project_id, title, status, assignee_id, due_date, priority）
	•	task_comments（task_id, user_id, content）

关键工程点（面试官爱看）
	•	强制隔离：任何 task/project 的查询/更新都必须验证其 workspace_id 属于当前用户
	•	任务状态机：TODO/DOING/DONE/BLOCKED
	•	列表分页、排序、过滤（status、assignee、due）

Done 标准
	•	CRUD API 完整
	•	用例覆盖：跨 workspace 访问必须 403/404（至少 4 个用例）

⸻

Day 5：RBAC 权限校验（依赖注入）+ 审计日志

目标

把权限做成“框架化组件”，并记录关键操作。

RBAC 落地方式（推荐）
	•	FastAPI dependency：require_role(min_role=...)
	•	或基于权限点：TASK_WRITE、PROJECT_ADMIN（更细，但更费时）

建议先做“角色分级 + 最少权限”：
	•	OWNER：全部
	•	ADMIN：除删除 workspace 外全部
	•	MEMBER：任务/评论/查看
	•	GUEST：只读

审计日志表
	•	audit_logs：
	•	workspace_id, actor_id, action, entity_type, entity_id, meta_json, created_at

记录动作示例：
	•	PROJECT_CREATE
	•	TASK_UPDATE_STATUS
	•	MEMBER_INVITE

Redis（可加缓存加速权限）
	•	perm:ws:{workspace_id}:user:{user_id} → role，TTL=5-15min
	•	当成员角色变更时删除相关 key

Done 标准
	•	RBAC 覆盖所有写操作
	•	audit log 对关键写操作落库
	•	pytest：权限边界至少 8 个用例（不同角色）

⸻

Day 6：Redis 工程化应用（缓存 + 限流 二选一必做；两者都做更强）

目标

让 Redis 不只是“摆设”，而是可解释的性能/稳定性组件。

选项 1：缓存（推荐）

缓存接口：
	•	GET /workspaces/{id}/dashboard（统计：任务总数、按状态分布、逾期数）
Redis：
	•	cache:ws:{id}:dashboard TTL=30-120s
失效策略：
	•	task 状态/新增/删除时删除该 key

选项 2：限流（很加分）
	•	登录接口限流：每 IP 每分钟 5 次
	•	邀请接口限流：每 workspace 每分钟 10 次
Redis key：
	•	rl:login:{ip}:{minute} 自增 + 过期
	•	rl:invite:ws:{id}:{minute}

Done 标准
	•	至少一个接口“可证明”用了缓存或限流（README 写清楚）
	•	加 4-6 个测试：缓存命中/失效；限流触发 429

⸻

Day 7：打磨交付（测试、文档、部署、演示）

目标

让它变成“能被面试官快速跑起来并认可”的项目。

任务清单
	•	README：
	•	项目简介（2-3 行）
	•	架构组件（FastAPI/MySQL/Redis/Worker）
	•	一键启动
	•	环境变量
	•	核心功能列表
	•	权限矩阵（表格最好）
	•	关键 Redis Key 说明
	•	测试：
	•	总数建议 20+（鉴权、RBAC、隔离、刷新 token、邀请流、缓存/限流）
	•	数据库索引：
	•	workspace_members (workspace_id, user_id) unique
	•	projects (workspace_id)
	•	tasks (project_id, status, assignee_id, due_date)
	•	部署（可选但很加分）：
	•	Render/Fly.io/Railway 任一（MySQL/Redis 可用托管或容器）

Done 标准
	•	新电脑 clone repo 后 5 分钟跑起来
	•	pytest 全绿
	•	README 足够“带看官走一遍”

⸻

数据库表（最小可用版本）

你可以直接按这个建模（后续我也能帮你写 Alembic migration）：
	1.	users(id, email, password_hash, name, created_at)
	2.	workspaces(id, name, owner_id, created_at)
	3.	workspace_members(id, workspace_id, user_id, role, created_at) + unique(workspace_id,user_id)
	4.	invites(id, workspace_id, email, token, status, expires_at, created_at)
	5.	projects(id, workspace_id, name, description, created_at)
	6.	tasks(id, project_id, title, status, priority, assignee_id, due_date, created_at, updated_at)
	7.	task_comments(id, task_id, user_id, content, created_at)
	8.	audit_logs(id, workspace_id, actor_id, action, entity_type, entity_id, meta_json, created_at)

⸻

核心接口清单（面试官一眼懂）
	•	Auth
	•	POST /auth/register
	•	POST /auth/login
	•	POST /auth/refresh
	•	POST /auth/logout
	•	Workspace
	•	POST /workspaces
	•	GET /workspaces
	•	POST /workspaces/{id}/invites
	•	POST /invites/accept
	•	GET /workspaces/{id}/members
	•	Project
	•	POST /workspaces/{id}/projects
	•	GET /workspaces/{id}/projects
	•	Task
	•	POST /projects/{id}/tasks
	•	GET /projects/{id}/tasks（filter/sort/page）
	•	PATCH /tasks/{id}（状态流转）
	•	POST /tasks/{id}/comments
	•	Audit
	•	GET /workspaces/{id}/audit-logs

⸻

你接下来怎么开始（最省心的执行顺序）
	1.	先做 Day1 的 docker + /health
	2.	Day2 把 auth 跑通（这是后面所有工作的地基）
	3.	Day3-5 逐步引入租户、业务实体、RBAC、审计
	4.	Day6 把 Redis 做“能讲清楚的工程价值”
	5.	Day7 打磨交付

⸻

如果你愿意，我下一步可以直接给你：
	•	docker-compose.yml（api+mysql+redis+rqueue worker）
	•	FastAPI 项目骨架代码（SQLAlchemy2 + Alembic + settings）
	•	Day2 的 JWT + refresh rotation + Redis allowlist 的完整实现
